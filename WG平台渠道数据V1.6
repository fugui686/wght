from __future__ import annotations
import os
import sys
import re
import csv
import time
import random
import threading
import pytz
import shutil
import requests
import configparser
from dataclasses import dataclass
from datetime import datetime, date, timedelta
from typing import List, Dict, Any, Optional, Tuple, Set
from PyQt5 import QtWidgets, QtCore
from PyQt5.QtGui import QTextCursor
from PyQt5.QtCore import QByteArray
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtWidgets import QMessageBox

# ========================= 常量 =========================
BJ_TZ = pytz.timezone("Asia/Shanghai")

DATA_DIR_NAME = "data"
ALIAS_MAP_FILE = "子平台别名映射.txt"

FIRST_FILE = "first_deposit.csv"
RECHARGE_FILE = "daily_recharge.csv"
REGISTER_FILE = "register.csv"
VISIT_FILE = "daily_visit.csv"
LOGIN_FILE = "daily_login.csv"

MONTH_DIR_FMT_LEN = 7  # YYYY-MM


# ========================= 日志（线程安全） =========================
class LogEmitter(QtCore.QObject):
    message = QtCore.pyqtSignal(str)


log_emitter = LogEmitter()


def log(msg: str):
    print(msg)
    log_emitter.message.emit(msg)


# ========================= 路径 & 配置文件策略 =========================
def is_frozen() -> bool:
    return getattr(sys, "frozen", False)


def app_dir() -> str:
    if is_frozen():
        return os.path.dirname(sys.executable)
    return os.path.dirname(os.path.abspath(__file__))


def user_config_dir() -> str:
    if sys.platform.startswith("win"):
        base = os.environ.get("APPDATA", os.path.expanduser("~"))
        return os.path.join(base, "RetentionTool")
    base = os.path.join(os.path.expanduser("~"), ".config")
    return os.path.join(base, "retention_tool")


def is_dir_writable(d: str) -> bool:
    try:
        os.makedirs(d, exist_ok=True)
        testfile = os.path.join(d, ".write_test.tmp")
        with open(testfile, "w", encoding="utf-8") as f:
            f.write("ok")
        os.remove(testfile)
        return True
    except Exception:
        return False


def resolve_config_path_for_load() -> str:
    p1 = os.path.join(app_dir(), "config.ini")
    if os.path.exists(p1):
        return p1
    return os.path.join(user_config_dir(), "config.ini")


def resolve_config_path_for_save() -> str:
    d1 = app_dir()
    if is_dir_writable(d1):
        return os.path.join(d1, "config.ini")
    d2 = user_config_dir()
    os.makedirs(d2, exist_ok=True)
    return os.path.join(d2, "config.ini")


# ========================= 昨日结算状态（last_finalize_date） =========================
def load_last_finalize_date_from_ini() -> str:
    """从 config.ini 读取上次“结算昨日”的日期（YYYY-MM-DD）。读取失败返回空字符串。"""
    p = resolve_config_path_for_load()
    if not os.path.exists(p):
        return ""
    try:
        cp = configparser.ConfigParser()
        cp.read(p, encoding="utf-8")
        return (cp["DEFAULT"].get("last_finalize_date", "") or "").strip()
    except Exception:
        return ""


def save_last_finalize_date_to_ini(last_finalize_date: str) -> str:
    """只更新 config.ini 的 last_finalize_date 字段，尽量不破坏其他配置。返回写入的配置路径。"""
    p_load = resolve_config_path_for_load()
    p_save = resolve_config_path_for_save()

    cp = configparser.ConfigParser()
    if os.path.exists(p_load):
        cp.read(p_load, encoding="utf-8")

    if "DEFAULT" not in cp:
        cp["DEFAULT"] = {}
    cp["DEFAULT"]["last_finalize_date"] = (last_finalize_date or "").strip()

    with open(p_save, "w", encoding="utf-8") as f:
        cp.write(f)

    return p_save



def is_month_key(s: str) -> bool:
    s = (s or "").strip()
    if len(s) != MONTH_DIR_FMT_LEN or s[4] != "-":
        return False
    y, m = s.split("-", 1)
    if not (y.isdigit() and m.isdigit()):
        return False
    mi = int(m)
    return 1 <= mi <= 12


def month_key_from_date(d: date) -> str:
    return d.strftime("%Y-%m")


def site_root_dir(alias: str) -> str:
    d = os.path.join(app_dir(), DATA_DIR_NAME, alias.upper())
    os.makedirs(d, exist_ok=True)
    return d


def ensure_site_month_dir(alias: str, month_key: str) -> str:
    root = site_root_dir(alias)
    mdir = os.path.join(root, month_key)
    os.makedirs(mdir, exist_ok=True)
    return mdir


def site_month_file(alias: str, month_key: str, filename: str) -> str:
    return os.path.join(ensure_site_month_dir(alias, month_key), filename)


def list_site_month_dirs(alias: str) -> List[str]:
    root = site_root_dir(alias)
    try:
        names = os.listdir(root)
    except Exception:
        return []
    months = [n for n in names if os.path.isdir(os.path.join(root, n)) and is_month_key(n)]
    months.sort()
    return months


# ========================= CSV 读写 =========================
def read_csv(path: str) -> List[Dict[str, Any]]:
    if not os.path.exists(path):
        return []

    # 优先 utf-8 / utf-8-sig，其次 gbk（Windows/Excel 常见），最后兜底替换非法字符
    for enc in ("utf-8-sig", "utf-8", "gbk", "cp936"):
        try:
            with open(path, "r", encoding=enc, newline="") as f:
                return list(csv.DictReader(f))
        except UnicodeDecodeError:
            continue
        except Exception:
            # 其它异常（比如空文件/损坏）直接兜底
            break

    # 最后兜底：不让机器人因为坏编码崩溃
    with open(path, "r", encoding="utf-8", errors="replace", newline="") as f:
        return list(csv.DictReader(f))


def write_csv(path: str, fieldnames: List[str], rows: List[Dict[str, Any]]):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8", newline="") as f:
        w = csv.DictWriter(f, fieldnames=fieldnames)
        w.writeheader()
        for r in rows:
            w.writerow(r)


def append_csv(path: str, fieldnames: List[str], rows: List[Dict[str, Any]]):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    file_exists = os.path.exists(path)
    with open(path, "a", encoding="utf-8", newline="") as f:
        w = csv.DictWriter(f, fieldnames=fieldnames)
        if not file_exists:
            w.writeheader()
        for r in rows:
            w.writerow(r)


# ========================= 映射文件：自动生成 + 加载 =========================
def ensure_alias_map_file():
    path = os.path.join(app_dir(), ALIAS_MAP_FILE)
    if os.path.exists(path):
        return

    content = (
        "# 子平台别名映射文件\n"
        "# 格式：alias=child_id，例如：B01=2610\n"
        "# 说明：child_id=0 会被程序自动忽略（占位用）\n"
        "B01=2610\n"
        "B02=2706\n"
        "B03=3006\n"
    )
    with open(path, "w", encoding="utf-8") as f:
        f.write(content)
    log(f"[提示] 未找到 {ALIAS_MAP_FILE}，已自动生成默认文件：{path}")


def load_alias_map() -> Dict[str, str]:
    path = os.path.join(app_dir(), ALIAS_MAP_FILE)
    mp: Dict[str, str] = {}
    if not os.path.exists(path):
        return mp

    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            s = line.strip()
            if not s or s.startswith("#"):
                continue
            if "=" not in s:
                continue
            k, v = s.split("=", 1)
            k = k.strip().upper()
            v = v.strip()
            if not k or not v:
                continue
            if v in ("0", "0000"):
                continue
            mp[k] = v
    return mp


# ========================= 配置对象 =========================
@dataclass
class GlobalConfig:
    平台ID: str
    ht: str
    token: str
    bot_token: str
    chat_id: str  # str 存储

    # ✅ 新增：权限控制（Telegram user_id，多个用英文逗号分隔）
    super_admin_ids: str = ""
    admin_ids: str = ""

    # ✅ 新增：上次“结算昨日”的日期（YYYY-MM-DD）
    last_finalize_date: str = ""

    @staticmethod
    def normalize_ht(ht: str) -> str:
        ht_norm = (ht or "").strip()
        ht_norm = ht_norm.removeprefix("https://").removeprefix("http://").rstrip("/")
        return ht_norm


@dataclass
class SiteConfig:
    alias: str
    子平台ID: str
    平台ID: str
    ht: str
    token: str

    def month_file(self, month_key: str, filename: str) -> str:
        return site_month_file(self.alias, month_key, filename)

    def month_first_csv(self, month_key: str) -> str:
        return self.month_file(month_key, FIRST_FILE)

    def month_register_csv(self, month_key: str) -> str:
        return self.month_file(month_key, REGISTER_FILE)

    def month_login_csv(self, month_key: str) -> str:
        return self.month_file(month_key, LOGIN_FILE)

    def month_recharge_csv(self, month_key: str) -> str:
        return self.month_file(month_key, RECHARGE_FILE)

    def month_visit_csv(self, month_key: str) -> str:
        return self.month_file(month_key, VISIT_FILE)


def build_sites(global_cfg: GlobalConfig, alias_map: Dict[str, str]) -> List[SiteConfig]:
    sites = []
    for alias, child_id in alias_map.items():
        sites.append(SiteConfig(
            alias=alias.upper(),
            子平台ID=child_id,
            平台ID=global_cfg.平台ID,
            ht=global_cfg.ht,
            token=global_cfg.token,
        ))
    return sites


# ========================= 时间工具 =========================
def day_ts_range(d: date) -> Tuple[int, int]:
    start = BJ_TZ.localize(datetime(d.year, d.month, d.day, 0, 0, 0))
    end = BJ_TZ.localize(datetime(d.year, d.month, d.day, 23, 59, 59))
    return int(start.timestamp()), int(end.timestamp())


def is_date_str(s: str) -> bool:
    try:
        datetime.strptime(s, "%Y-%m-%d")
        return True
    except Exception:
        return False


# ========================= 请求工具（仅出问题才 sleep） =========================
def get_headers(平台ID: str, 子平台ID: str, ht: str, token: str) -> Dict[str, str]:
    if not ht or not token or not 平台ID:
        raise RuntimeError("配置缺失：请先填写 ht、token、平台ID")
    return {
        "accept": "application/json, text/plain, */*",
        "accept-language": "zh-CN,zh;q=0.9",
        "childsitecode": 子平台ID or "0",
        "companycode": 平台ID,
        "content-type": "application/json",
        "cookie": token.strip(),
        "loginbacktype": "3",
        "sitecode": 平台ID,
    }


def _sleep_backoff(attempt: int, reason: str, base: float = 0.8, cap: float = 8.0):
    """
    attempt: 从 1 开始
    指数退避 + 随机抖动，仅在出问题时触发
    """
    # 0.8, 1.6, 3.2, 6.4... 封顶 8
    delay = min(cap, base * (2 ** (attempt - 1)))
    jitter = random.uniform(0.7, 1.4)
    sleep_s = max(0.2, delay * jitter)
    log(f"[退避] {reason}，第{attempt}次重试：sleep {sleep_s:.2f}s")
    time.sleep(sleep_s)


def post_json_with_retry(
    url: str,
    headers: Dict[str, str],
    payload: Dict[str, Any],
    retries: int = 3,
    timeout: int = 20,
) -> Optional[Dict[str, Any]]:
    """
    ✅ 分页不 sleep
    ✅ 仅当异常/超时/429/5xx/JSON解析失败 才 sleep 并重试
    """
    last_text = ""
    for attempt in range(1, retries + 2):
        try:
            resp = requests.post(url, headers=headers, json=payload, timeout=timeout)
            status = resp.status_code
            last_text = (resp.text or "")[:300]

            if status != 200:
                # 仅对 429/5xx 做退避重试
                if status == 429 or (500 <= status <= 599):
                    if attempt <= retries:
                        _sleep_backoff(attempt, f"HTTP {status}")
                        continue
                log(f"[HTTP {status}] {url}")
                if last_text:
                    log(last_text)
                return None

            try:
                js = resp.json()
            except Exception as e:
                # JSON 解析失败也当成可重试问题（可能是网关返回了HTML/空串）
                if attempt <= retries:
                    _sleep_backoff(attempt, f"JSON解析失败: {e}")
                    continue
                log(f"[错误] JSON解析失败: {e}")
                if last_text:
                    log(last_text)
                return None

            if not isinstance(js, dict):
                if attempt <= retries:
                    _sleep_backoff(attempt, "返回非dict JSON")
                    continue
                log("[错误] 返回非 JSON dict")
                return None

            return js

        except requests.RequestException as e:
            # 网络问题/超时 -> 退避重试
            if attempt <= retries:
                _sleep_backoff(attempt, f"请求异常: {e}")
                continue
            log(f"[异常] 请求失败（已达重试上限）：{e}")
            return None
        except Exception as e:
            # 其它未知异常也退避一次
            if attempt <= retries:
                _sleep_backoff(attempt, f"未知异常: {e}")
                continue
            log(f"[异常] 未知异常（已达重试上限）：{e}")
            return None

    return None


# ========================= 5 个接口：抓取（单站点/单日） =========================
def fetch_first_deposit_for_day(cfg: SiteConfig, d: date) -> List[Dict[str, Any]]:
    start_ts, end_ts = day_ts_range(d)
    url = f"https://{cfg.ht}/api/go-gateway-internal/user/advancedGetUserListV2"
    all_rows: List[Dict[str, Any]] = []
    page, size = 1, 1000
    d_str = d.strftime("%Y-%m-%d")
    headers = get_headers(cfg.平台ID, cfg.子平台ID, cfg.ht, cfg.token)

    while True:
        payload = {
            "selectTimeKey": 2,
            "accountTypes": [],
            "current": page,
            "size": size,
            "firstPayTimeFrom": start_ts,
            "firstPayTimeTo": end_ts,
            "childSiteCode": cfg.子平台ID or "0",
        }
        js = post_json_with_retry(url, headers, payload)
        if not js:
            log(f"[{cfg.alias}][首存] {d_str} 第{page}页 获取失败")
            break

        data_wrapper = js.get("data") or {}
        data = data_wrapper.get("data") or data_wrapper.get("list") or []
        if not data:
            break

        for item in data:
            user_id = item.get("useridx") or item.get("userIdx")
            if not user_id:
                continue
            first_amount_raw = item.get("firstPayAmount")
            try:
                first_amount = float(first_amount_raw) if first_amount_raw is not None else 0.0
            except Exception:
                first_amount = 0.0
            if first_amount <= 0:
                continue

            channel = (item.get("regpkgidName") or "").strip()
            all_rows.append({
                "user_id": str(user_id),
                "first_date": d_str,
                "first_amount": first_amount,
                "channel": channel,
            })

        if len(data) < size:
            break
        page += 1

    log(f"[{cfg.alias}][首存] {d_str} 获取到 {len(all_rows)} 条记录")
    return all_rows


def fetch_register_for_day(cfg: SiteConfig, d: date) -> List[Dict[str, Any]]:
    start_ts, end_ts = day_ts_range(d)
    url = f"https://{cfg.ht}/api/go-gateway-internal/user/advancedGetUserListV2"
    all_rows: List[Dict[str, Any]] = []
    page, size = 1, 1000
    d_str = d.strftime("%Y-%m-%d")
    headers = get_headers(cfg.平台ID, cfg.子平台ID, cfg.ht, cfg.token)

    while True:
        payload = {
            "selectTimeKey": 0,
            "accountTypes": [],
            "current": page,
            "size": size,
            "registerTimeFrom": start_ts,
            "registerTimeTo": end_ts,
            "childSiteCode": cfg.子平台ID or "0",
        }
        js = post_json_with_retry(url, headers, payload)
        if not js:
            log(f"[{cfg.alias}][注册] {d_str} 第{page}页 获取失败")
            break

        data_wrapper = js.get("data") or {}
        data = data_wrapper.get("data") or data_wrapper.get("list") or []
        if not data:
            break

        for item in data:
            user_id = item.get("useridx") or item.get("userIdx")
            if not user_id:
                continue
            channel = (item.get("regpkgidName") or "").strip()
            all_rows.append({
                "user_id": str(user_id),
                "reg_date": d_str,
                "channel": channel,
            })

        if len(data) < size:
            break
        page += 1

    log(f"[{cfg.alias}][注册] {d_str} 获取到 {len(all_rows)} 条记录")
    return all_rows


def fetch_login_for_day(cfg: SiteConfig, d: date) -> List[Dict[str, Any]]:
    start_ts, end_ts = day_ts_range(d)
    url = f"https://{cfg.ht}/api/go-gateway-internal/user/getUserActionLogs"
    all_rows: List[Dict[str, Any]] = []
    seen_users: Set[str] = set()
    page, size = 1, 1000
    d_str = d.strftime("%Y-%m-%d")
    headers = get_headers(cfg.平台ID, cfg.子平台ID, cfg.ht, cfg.token)

    while True:
        payload = {
            "childSiteCode": cfg.子平台ID or "0",
            "timeStart": start_ts,
            "timeEnd": end_ts,
            "operationType": 1,
            "actionItems": 1,
            "name": 25,
            "result": "0",
            "current": page,
            "size": size,
        }
        js = post_json_with_retry(url, headers, payload)
        if not js:
            log(f"[{cfg.alias}][登录] {d_str} 第{page}页 获取失败")
            break

        data_wrapper = js.get("data") or {}
        data = data_wrapper.get("data") or data_wrapper.get("list") or []
        if not data:
            break

        for item in data:
            user_id = item.get("useridx") or item.get("userIdx")
            if not user_id:
                continue
            uid_str = str(user_id)
            if uid_str in seen_users:
                continue
            seen_users.add(uid_str)
            all_rows.append({"user_id": uid_str, "login_date": d_str})

        if len(data) < size:
            break
        page += 1

    log(f"[{cfg.alias}][登录] {d_str} 获取到 {len(all_rows)} 条记录（去重后）")
    return all_rows


def fetch_member_report_for_day(cfg: SiteConfig, d: date) -> List[Dict[str, Any]]:
    start_ts, end_ts = day_ts_range(d)
    url = f"https://{cfg.ht}/api/go-gateway-internal/noEncrypt/statistics/report/user_report"
    all_rows: List[Dict[str, Any]] = []
    page, size = 1, 1000
    d_str = d.strftime("%Y-%m-%d")
    headers = get_headers(cfg.平台ID, cfg.子平台ID, cfg.ht, cfg.token)

    while True:
        payload = {
            "currency": "CNY",
            "startTime": start_ts,
            "endTime": end_ts,
            "childSiteCode": cfg.子平台ID or "0",
            "pageSort": {"page": page, "limit": size},
        }
        js = post_json_with_retry(url, headers, payload)
        if not js:
            log(f"[{cfg.alias}][会员报表] {d_str} 第{page}页 获取失败")
            break

        data_wrapper = js.get("data") or {}
        data = data_wrapper.get("list") or data_wrapper.get("data") or []
        if not data:
            break

        for item in data:
            user_id = item.get("userIdx") or item.get("useridx")
            if not user_id:
                continue

            try:
                deposit = float(item.get("deposit", 0) or 0)
            except Exception:
                deposit = 0.0

            try:
                withdraw_amount = float(item.get("withdraw", 0) or 0)
            except Exception:
                withdraw_amount = 0.0

            # ✅ 关键修复：充值>0 或 提现>0 都要入库
            if deposit > 0 or withdraw_amount > 0:
                all_rows.append({
                    "user_id": str(user_id),
                    "pay_date": d_str,
                    "pay_amount": deposit,
                    "withdraw_amount": withdraw_amount,
                })

        if len(data) < size:
            break
        page += 1

    log(f"[{cfg.alias}][会员报表] {d_str} 获取到 {len(all_rows)} 条记录")
    return all_rows


def fetch_visit_for_day(cfg: SiteConfig, d: date) -> List[Dict[str, Any]]:
    start_ts, end_ts = day_ts_range(d)
    url = f"https://{cfg.ht}/api/go-gateway-internal/noEncrypt/statistics/channel/channel_download_report"
    d_str = d.strftime("%Y-%m-%d")
    headers = get_headers(cfg.平台ID, cfg.子平台ID, cfg.ht, cfg.token)

    page, size = 1, 1000
    visits_by_channel: Dict[str, float] = {}

    while True:
        payload = {
            "childSiteCode": cfg.子平台ID or "0",
            "valField": "visits",
            "startTime": start_ts,
            "endTime": end_ts,
            "pageSort": {"page": page, "limit": size},
        }
        js = post_json_with_retry(url, headers, payload)
        if not js:
            log(f"[{cfg.alias}][访问量] {d_str} 第{page}页 获取失败")
            break

        data_wrapper = js.get("data") or {}
        data = data_wrapper.get("list") or data_wrapper.get("data") or []
        if not data:
            break

        for item in data:
            channel = (item.get("channelName") or "").strip()
            if not channel:
                continue
            try:
                visits = float(item.get("visits", 0) or 0)
            except Exception:
                visits = 0.0
            visits_by_channel[channel] = visits_by_channel.get(channel, 0.0) + visits

        if len(data) < size:
            break
        page += 1

    rows = [{"channel": ch, "visit_date": d_str, "visit_count": cnt} for ch, cnt in visits_by_channel.items()]
    log(f"[{cfg.alias}][访问量] {d_str} 获取到 {len(rows)} 条记录")
    return rows


# ========================= 保存到“当月csv”（去重/聚合） =========================
def save_first_deposit_month(cfg: SiteConfig, month_key: str, new_rows: List[Dict[str, Any]]):
    if not new_rows:
        return
    path = cfg.month_first_csv(month_key)
    fieldnames = ["user_id", "first_date", "first_amount", "channel"]
    exist = read_csv(path)
    by_user = {r["user_id"]: r for r in exist if r.get("user_id")}

    for r in new_rows:
        uid = r["user_id"]
        if uid in by_user:
            if r["first_date"] < by_user[uid].get("first_date", "9999-12-31"):
                by_user[uid] = r
        else:
            by_user[uid] = r

    write_csv(path, fieldnames, list(by_user.values()))


def save_register_month(cfg: SiteConfig, month_key: str, new_rows: List[Dict[str, Any]]):
    if not new_rows:
        return
    path = cfg.month_register_csv(month_key)
    fieldnames = ["user_id", "reg_date", "channel"]
    exist = read_csv(path)
    by_user = {r["user_id"]: r for r in exist if r.get("user_id")}

    for r in new_rows:
        uid = r["user_id"]
        if uid in by_user:
            if r["reg_date"] < by_user[uid].get("reg_date", "9999-12-31"):
                by_user[uid] = r
        else:
            by_user[uid] = r

    write_csv(path, fieldnames, list(by_user.values()))


def save_login_month(cfg: SiteConfig, month_key: str, new_rows: List[Dict[str, Any]]):
    if not new_rows:
        return
    path = cfg.month_login_csv(month_key)
    fieldnames = ["user_id", "login_date"]
    exist = read_csv(path)
    seen = {(r.get("user_id", ""), r.get("login_date", "")) for r in exist}

    to_write = []
    for r in new_rows:
        key = (r.get("user_id", ""), r.get("login_date", ""))
        if key in seen:
            continue
        seen.add(key)
        to_write.append({"user_id": str(r.get("user_id", "")), "login_date": str(r.get("login_date", ""))})

    if to_write:
        append_csv(path, fieldnames, to_write)


def save_member_report_month(cfg: SiteConfig, month_key: str, new_rows: List[Dict[str, Any]]):
    """
    ✅ 目标：daily_recharge.csv 中，每个账号每天只保留 1 条
    ✅ 策略：按 (user_id, pay_date) 覆盖为“本次抓到的累计值”（最新覆盖）
    """
    if not new_rows:
        return

    path = cfg.month_recharge_csv(month_key)
    fieldnames = ["user_id", "pay_date", "pay_amount", "withdraw_amount"]

    # 读取旧数据
    exist = read_csv(path)

    # 用 (user_id, pay_date) 做唯一键
    by_key: Dict[Tuple[str, str], Dict[str, Any]] = {}

    # 先塞旧数据
    for r in exist:
        uid = str((r.get("user_id") or "")).strip()
        d = str((r.get("pay_date") or "")).strip()
        if not uid or not d:
            continue
        by_key[(uid, d)] = {
            "user_id": uid,
            "pay_date": d,
            "pay_amount": safe_float(r.get("pay_amount", 0)),
            "withdraw_amount": safe_float(r.get("withdraw_amount", 0)),
        }

    # 再用本次新抓到的数据覆盖（最新覆盖）
    for r in new_rows:
        uid = str((r.get("user_id") or "")).strip()
        d = str((r.get("pay_date") or "")).strip()
        if not uid or not d:
            continue

        pay = safe_float(r.get("pay_amount", 0))
        wd = safe_float(r.get("withdraw_amount", 0))

        by_key[(uid, d)] = {
            "user_id": uid,
            "pay_date": d,
            "pay_amount": pay,
            "withdraw_amount": wd,
        }

    # 写回整月文件（覆盖写，保证唯一性）
    # 可选：按日期、user_id 排序，方便查
    rows_out = list(by_key.values())
    rows_out.sort(key=lambda x: (str(x.get("pay_date", "")), str(x.get("user_id", ""))))

    write_csv(path, fieldnames, rows_out)


def save_visit_month(cfg: SiteConfig, month_key: str, new_rows: List[Dict[str, Any]]):
    if not new_rows:
        return
    path = cfg.month_visit_csv(month_key)
    fieldnames = ["channel", "visit_date", "visit_count"]
    exist = read_csv(path)

    by_key: Dict[Tuple[str, str], Dict[str, Any]] = {}
    for r in exist:
        ch = (r.get("channel") or "").strip()
        vd = (r.get("visit_date") or "").strip()
        if not ch or not vd:
            continue
        try:
            cnt = float(r.get("visit_count", 0) or 0)
        except Exception:
            cnt = 0.0
        by_key[(ch.lower(), vd)] = {"channel": ch, "visit_date": vd, "visit_count": cnt}

    for r in new_rows:
        ch = (r.get("channel") or "").strip()
        vd = (r.get("visit_date") or "").strip()
        if not ch or not vd:
            continue
        try:
            cnt = float(r.get("visit_count", 0) or 0)
        except Exception:
            cnt = 0.0
        by_key[(ch.lower(), vd)] = {"channel": ch, "visit_date": vd, "visit_count": cnt}

    write_csv(path, fieldnames, list(by_key.values()))


# ========================= 每日更新 / 补历史（单站点） =========================
def 每日更新_单站点(cfg: SiteConfig, include_yesterday: bool = True) -> str:
    today = date.today()
    yesterday = today - timedelta(days=1)

    dates = (yesterday, today) if include_yesterday else (today,)
    if include_yesterday:
        log(f"=== [{cfg.alias}] 每日更新: 处理昨日 {yesterday} + 今日 {today} ===")
    else:
        log(f"=== [{cfg.alias}] 每日更新: 已结算昨日，仅处理今日 {today} ===")

    for d in dates:
        mkey = month_key_from_date(d)

        reg_rows = fetch_register_for_day(cfg, d)
        save_register_month(cfg, mkey, reg_rows)

        login_rows = fetch_login_for_day(cfg, d)
        save_login_month(cfg, mkey, login_rows)

        fd_rows = fetch_first_deposit_for_day(cfg, d)
        save_first_deposit_month(cfg, mkey, fd_rows)

        rc_rows = fetch_member_report_for_day(cfg, d)
        save_member_report_month(cfg, mkey, rc_rows)

        vt_rows = fetch_visit_for_day(cfg, d)
        save_visit_month(cfg, mkey, vt_rows)

    return f"[{cfg.alias}] 每日更新完成：{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"


def _filter_month_csv_by_date_range(path: str, date_field: str, start_str: str, end_str: str) -> int:
    if not os.path.exists(path):
        return 0
    rows = read_csv(path)
    if not rows:
        return 0

    kept = []
    removed = 0
    for r in rows:
        ds = (r.get(date_field) or "").strip()
        if len(ds) == 10 and start_str <= ds <= end_str:
            removed += 1
            continue
        kept.append(r)

    if removed > 0:
        fieldnames = list(rows[0].keys())
        write_csv(path, fieldnames, kept)
    return removed


def 补历史_单站点(cfg: SiteConfig, 开始日期: date, 结束日期: date) -> str:
    start_str = 开始日期.strftime("%Y-%m-%d")
    end_str = 结束日期.strftime("%Y-%m-%d")
    log(f"[{cfg.alias}] 补历史：{开始日期} ~ {结束日期}（按月文件删除区间后重抓）")

    months: Set[str] = set()
    cur = 开始日期
    while cur <= 结束日期:
        months.add(month_key_from_date(cur))
        cur += timedelta(days=1)
    month_list = sorted(months)

    removed_sum = 0
    for mkey in month_list:
        removed_sum += _filter_month_csv_by_date_range(cfg.month_register_csv(mkey), "reg_date", start_str, end_str)
        removed_sum += _filter_month_csv_by_date_range(cfg.month_first_csv(mkey), "first_date", start_str, end_str)
        removed_sum += _filter_month_csv_by_date_range(cfg.month_recharge_csv(mkey), "pay_date", start_str, end_str)
        removed_sum += _filter_month_csv_by_date_range(cfg.month_visit_csv(mkey), "visit_date", start_str, end_str)
        removed_sum += _filter_month_csv_by_date_range(cfg.month_login_csv(mkey), "login_date", start_str, end_str)
    log(f"[{cfg.alias}] 补历史前：已清理区间旧数据 {removed_sum} 行")

    cur = 开始日期
    while cur <= 结束日期:
        mkey = month_key_from_date(cur)
        log(f"=== [{cfg.alias}] 补历史: 处理日期 {cur} ===")

        reg_rows = fetch_register_for_day(cfg, cur)
        save_register_month(cfg, mkey, reg_rows)

        login_rows = fetch_login_for_day(cfg, cur)
        save_login_month(cfg, mkey, login_rows)

        fd_rows = fetch_first_deposit_for_day(cfg, cur)
        save_first_deposit_month(cfg, mkey, fd_rows)

        rc_rows = fetch_member_report_for_day(cfg, cur)
        save_member_report_month(cfg, mkey, rc_rows)

        vt_rows = fetch_visit_for_day(cfg, cur)
        save_visit_month(cfg, mkey, vt_rows)

        cur += timedelta(days=1)

    return f"[{cfg.alias}] 补历史完成：{开始日期} ~ {结束日期}"


# ========================= 全站点运行 =========================
def 每日更新_全站点(global_cfg: GlobalConfig, alias_map: Dict[str, str]) -> str:
    sites = build_sites(global_cfg, alias_map)
    if not sites:
        raise RuntimeError(f"映射文件为空/无有效站点：{ALIAS_MAP_FILE}")

    today_str = date.today().strftime("%Y-%m-%d")
    last_done = (global_cfg.last_finalize_date or "").strip()

    # ✅ 方案A：同一天内只结算一次昨日（其余每小时仅抓今日，速度更快）
    include_yesterday = (last_done != today_str)
    if include_yesterday:
        log(f"[每日更新优化] 今日首次运行：将结算昨日一次（last_finalize_date={last_done or '空'} -> {today_str}）")
    else:
        log(f"[每日更新优化] 今日已结算昨日（last_finalize_date={last_done}），本次仅抓今日数据")

    msgs = []
    for s in sites:
        msgs.append(每日更新_单站点(s, include_yesterday=include_yesterday))

    # ✅ 所有站点都成功后，才写入“已结算”标记
    if include_yesterday:
        global_cfg.last_finalize_date = today_str
        p = save_last_finalize_date_to_ini(today_str)
        log(f"[每日更新优化] 已写入 last_finalize_date={today_str} 到配置：{p}")

    return "全站点每日更新完成：\n" + "\n".join(msgs)


def 补历史_全站点(global_cfg: GlobalConfig, alias_map: Dict[str, str], start_d: date, end_d: date) -> str:
    sites = build_sites(global_cfg, alias_map)
    if not sites:
        raise RuntimeError(f"映射文件为空/无有效站点：{ALIAS_MAP_FILE}")
    msgs = []
    for s in sites:
        msgs.append(补历史_单站点(s, start_d, end_d))
    return "全站点补历史完成：\n" + "\n".join(msgs)


# ========================= 清理旧数据（按月目录删除） =========================
def first_day_of_month(d: date) -> date:
    return date(d.year, d.month, 1)


def add_months(d: date, months: int) -> date:
    y = d.year + (d.month - 1 + months) // 12
    m = (d.month - 1 + months) % 12 + 1
    return date(y, m, 1)


def calc_cutoff_month_key(months_to_keep: int, today: Optional[date] = None) -> str:
    if today is None:
        today = date.today()
    if months_to_keep < 1:
        months_to_keep = 1
    this_month = first_day_of_month(today)
    earliest_month = add_months(this_month, -(months_to_keep - 1))
    return earliest_month.strftime("%Y-%m")


def cleanup_site_month_dirs(site_cfg: SiteConfig, months_to_keep: int) -> Tuple[str, List[str]]:
    cutoff_m = calc_cutoff_month_key(months_to_keep)
    months = list_site_month_dirs(site_cfg.alias)
    to_delete = [m for m in months if m < cutoff_m]

    deleted = []
    for m in to_delete:
        p = os.path.join(site_root_dir(site_cfg.alias), m)
        try:
            shutil.rmtree(p)
            deleted.append(m)
        except Exception as e:
            log(f"[{site_cfg.alias}][清理] 删除月份目录失败 {p}：{e}")

    return cutoff_m, deleted


def cleanup_all_sites(global_cfg: GlobalConfig, alias_map: Dict[str, str], months_to_keep: int) -> str:
    sites = build_sites(global_cfg, alias_map)
    if not sites:
        raise RuntimeError(f"映射文件为空/无有效站点：{ALIAS_MAP_FILE}")

    cutoff_m = calc_cutoff_month_key(months_to_keep)
    total_deleted = 0
    for s in sites:
        _, deleted = cleanup_site_month_dirs(s, months_to_keep)
        if deleted:
            log(f"[{s.alias}][清理] 删除月份：{', '.join(deleted)}")
        total_deleted += len(deleted)

    return f"清理完成：保留最近 {months_to_keep} 个月（含本月），最早保留月份 {cutoff_m}，共删除 {total_deleted} 个月份目录"


# ========================= 统计辅助 =========================
def norm(s: Any) -> str:
    return str(s or "").strip().lower()


def safe_int(x: Any) -> int:
    try:
        return int(float(x))
    except Exception:
        return 0


def safe_float(x: Any) -> float:
    try:
        return float(x)
    except Exception:
        return 0.0


def unique_user_key(site_alias: str, user_id: str) -> str:
    return f"{site_alias.upper()}::{user_id}"


def title_scope_all() -> str:
    return "组合：全部平台（所有渠道）"


def title_scope_site() -> str:
    return "组合：指定平台（所有渠道）"


def title_scope_channel(channel: str) -> str:
    return f"渠道：{channel}"


def month_of_date_str(d_str: str) -> str:
    return d_str[:7]


# ========================= 统计：转换比（支持渠道过滤） =========================
def calc_visit_register_first(
    scope_sites: List[SiteConfig],
    target_date: str,
    channel_filter: Optional[str] = None,
) -> Tuple[int, int, int]:
    chf = norm(channel_filter) if channel_filter else None
    mkey = month_of_date_str(target_date)

    total_visits = 0
    reg_users: Set[str] = set()
    first_users: Set[str] = set()

    for s in scope_sites:
        for r in read_csv(s.month_visit_csv(mkey)):
            if (r.get("visit_date") or "") != target_date:
                continue
            if chf and norm(r.get("channel")) != chf:
                continue
            total_visits += safe_int(r.get("visit_count", 0))

        for r in read_csv(s.month_register_csv(mkey)):
            if (r.get("reg_date") or "") != target_date:
                continue
            if chf and norm(r.get("channel")) != chf:
                continue
            uid = (r.get("user_id") or "").strip()
            if uid:
                reg_users.add(unique_user_key(s.alias, uid))

        for r in read_csv(s.month_first_csv(mkey)):
            if (r.get("first_date") or "") != target_date:
                continue
            if chf and norm(r.get("channel")) != chf:
                continue
            uid = (r.get("user_id") or "").strip()
            if uid:
                first_users.add(unique_user_key(s.alias, uid))

    return total_visits, len(reg_users), len(first_users)


def format_reply_convert(title: str, date_str: str, total_visits: int, total_reg: int, total_first: int) -> str:
    ratio = (total_first / total_reg * 100.0) if total_reg > 0 else 0.0
    return (
        f"{title}\n"
        f"日期：{date_str}\n"
        f"总访问量：{total_visits}\n\n"
        f"注册人数：{total_reg}\n"
        f"首存人数：{total_first}\n"
        f"转换比例：{ratio:.2f}%"
    )


# ========================= 统计：金额区间（支持渠道过滤） =========================
def calc_amount_ranges(
    scope_sites: List[SiteConfig],
    first_date: str,
    channel_filter: Optional[str] = None,
) -> Dict[str, Any]:
    chf = norm(channel_filter) if channel_filter else None
    mkey = month_of_date_str(first_date)

    # 新金额区间：
    # 10
    # 11-30
    # 31-50
    # 51-100
    # 101+
    buckets = [
        ("10元", 10.0, 10.0),
        ("11~30元", 11.0, 30.0),
        ("31~50元", 31.0, 50.0),
        ("51~100元", 51.0, 100.0),
        ("101元以上", 101.0, float("inf")),
    ]

    amounts: Dict[str, float] = {}
    for s in scope_sites:
        for r in read_csv(s.month_first_csv(mkey)):
            if (r.get("first_date") or "") != first_date:
                continue
            if chf and norm(r.get("channel")) != chf:
                continue
            uid = (r.get("user_id") or "").strip()
            if not uid:
                continue
            amt = safe_float(r.get("first_amount", 0))
            if amt <= 0:
                continue
            amounts[unique_user_key(s.alias, uid)] = amt

    total_users = len(amounts)
    total_amount = sum(amounts.values())

    res = []
    for name, lo, hi in buckets:
        cnt = 0
        amt_sum = 0.0
        for amt in amounts.values():
            if hi == float("inf"):
                if amt >= lo:
                    cnt += 1
                    amt_sum += amt
            else:
                if lo <= amt <= hi:
                    cnt += 1
                    amt_sum += amt

        cnt_pct = (cnt / total_users * 100.0) if total_users > 0 else 0.0
        amt_pct = (amt_sum / total_amount * 100.0) if total_amount > 0 else 0.0
        res.append({"name": name, "cnt": cnt, "amt": amt_sum, "cnt_pct": cnt_pct, "amt_pct": amt_pct})

    return {"total_users": total_users, "total_amount": total_amount, "ranges": res}


def format_reply_amount_ranges(title: str, first_date: str, stats: Dict[str, Any]) -> str:
    total_users = stats["total_users"]
    total_amount = stats["total_amount"]
    lines = [
        title,
        f"首存日期：{first_date}",
        f"总首存人数：{total_users}",
        f"总首存金额：{int(total_amount)}",
        "",
        "*【金额区间统计】*",
    ]
    for item in stats["ranges"]:
        # ✅ 区间名加粗：10元： / 11~30元： / 31~50元：...
        lines.append(f"*{item['name']}*：")
        lines.append(f"    首存人数：{item['cnt']}")
        lines.append(f"    首存金额：{int(item['amt'])}")
        lines.append(f"    人数占比：{item['cnt_pct']:.2f}%")
        lines.append(f"    金额占比：{item['amt_pct']:.2f}%\n")
    return "\n".join(lines)


# ========================= 汇总（省略：与上一版一致，为了不让你复制内容过长） =========================
# 说明：为了保持你复制覆盖的“完整可运行”，下面直接给你完整实现（未删减）。

def _earliest_date_in_scope_all_months(
    scope_sites: List[SiteConfig],
    channel_filter: Optional[str] = None,
) -> str:
    chf = norm(channel_filter) if channel_filter else None
    dates: List[str] = []

    if not chf:
        for s in scope_sites:
            for m in list_site_month_dirs(s.alias):
                for r in read_csv(s.month_visit_csv(m)):
                    ds = (r.get("visit_date") or "").strip()
                    if len(ds) == 10:
                        dates.append(ds)
                for r in read_csv(s.month_register_csv(m)):
                    ds = (r.get("reg_date") or "").strip()
                    if len(ds) == 10:
                        dates.append(ds)
                for r in read_csv(s.month_first_csv(m)):
                    ds = (r.get("first_date") or "").strip()
                    if len(ds) == 10:
                        dates.append(ds)
                for r in read_csv(s.month_login_csv(m)):
                    ds = (r.get("login_date") or "").strip()
                    if len(ds) == 10:
                        dates.append(ds)
                for r in read_csv(s.month_recharge_csv(m)):
                    ds = (r.get("pay_date") or "").strip()
                    if len(ds) == 10:
                        dates.append(ds)
        return min(dates) if dates else ""

    channel_user_keys: Set[str] = set()

    for s in scope_sites:
        for m in list_site_month_dirs(s.alias):
            for r in read_csv(s.month_register_csv(m)):
                if norm(r.get("channel")) != chf:
                    continue
                ds = (r.get("reg_date") or "").strip()
                if len(ds) == 10:
                    dates.append(ds)
                uid = (r.get("user_id") or "").strip()
                if uid:
                    channel_user_keys.add(unique_user_key(s.alias, uid))

            for r in read_csv(s.month_first_csv(m)):
                if norm(r.get("channel")) != chf:
                    continue
                ds = (r.get("first_date") or "").strip()
                if len(ds) == 10:
                    dates.append(ds)
                uid = (r.get("user_id") or "").strip()
                if uid:
                    channel_user_keys.add(unique_user_key(s.alias, uid))

            for r in read_csv(s.month_visit_csv(m)):
                if norm(r.get("channel")) != chf:
                    continue
                ds = (r.get("visit_date") or "").strip()
                if len(ds) == 10:
                    dates.append(ds)

    per_site_uids: Dict[str, Set[str]] = {}
    for k in channel_user_keys:
        site_alias, uid = k.split("::", 1)
        per_site_uids.setdefault(site_alias, set()).add(uid)

    for s in scope_sites:
        uids = per_site_uids.get(s.alias.upper(), set())
        if not uids:
            continue
        for m in list_site_month_dirs(s.alias):
            for r in read_csv(s.month_login_csv(m)):
                uid = (r.get("user_id") or "").strip()
                if uid in uids:
                    ds = (r.get("login_date") or "").strip()
                    if len(ds) == 10:
                        dates.append(ds)
            for r in read_csv(s.month_recharge_csv(m)):
                uid = (r.get("user_id") or "").strip()
                if uid in uids:
                    ds = (r.get("pay_date") or "").strip()
                    if len(ds) == 10:
                        dates.append(ds)

    return min(dates) if dates else ""


def compute_summary(
    scope_sites: List[SiteConfig],
    target_date: Optional[str] = None,
    channel_filter: Optional[str] = None,
) -> Dict[str, Any]:
    chf = norm(channel_filter) if channel_filter else None
    start_date = _earliest_date_in_scope_all_months(scope_sites, channel_filter=channel_filter) or (target_date or "")

    total_visits = 0
    reg_users: Set[str] = set()
    first_users: Set[str] = set()
    first_amount_total = 0.0

    total_recharge = 0.0
    total_withdraw = 0.0

    if target_date:
        months = [month_of_date_str(target_date)]
    else:
        months = None

    if not chf:
        for s in scope_sites:
            month_list = months if months is not None else list_site_month_dirs(s.alias)
            for m in month_list:
                for r in read_csv(s.month_visit_csv(m)):
                    ds = (r.get("visit_date") or "").strip()
                    if target_date and ds != target_date:
                        continue
                    total_visits += safe_int(r.get("visit_count", 0))

                for r in read_csv(s.month_register_csv(m)):
                    ds = (r.get("reg_date") or "").strip()
                    if target_date and ds != target_date:
                        continue
                    uid = (r.get("user_id") or "").strip()
                    if uid:
                        reg_users.add(unique_user_key(s.alias, uid))

                for r in read_csv(s.month_first_csv(m)):
                    ds = (r.get("first_date") or "").strip()
                    if target_date and ds != target_date:
                        continue
                    uid = (r.get("user_id") or "").strip()
                    if uid:
                        k = unique_user_key(s.alias, uid)
                        if k not in first_users:
                            first_users.add(k)
                            first_amount_total += safe_float(r.get("first_amount", 0))

                for r in read_csv(s.month_recharge_csv(m)):
                    ds = (r.get("pay_date") or "").strip()
                    if target_date and ds != target_date:
                        continue
                    total_recharge += safe_float(r.get("pay_amount", 0))
                    total_withdraw += safe_float(r.get("withdraw_amount", 0))

    else:
        channel_users: Set[str] = set()

        for s in scope_sites:
            month_list = months if months is not None else list_site_month_dirs(s.alias)
            for m in month_list:
                for r in read_csv(s.month_visit_csv(m)):
                    if norm(r.get("channel")) != chf:
                        continue
                    ds = (r.get("visit_date") or "").strip()
                    if target_date and ds != target_date:
                        continue
                    total_visits += safe_int(r.get("visit_count", 0))

                for r in read_csv(s.month_register_csv(m)):
                    if norm(r.get("channel")) != chf:
                        continue
                    ds = (r.get("reg_date") or "").strip()
                    if target_date and ds != target_date:
                        continue
                    uid = (r.get("user_id") or "").strip()
                    if uid:
                        k = unique_user_key(s.alias, uid)
                        reg_users.add(k)
                        channel_users.add(k)

                for r in read_csv(s.month_first_csv(m)):
                    if norm(r.get("channel")) != chf:
                        continue
                    ds = (r.get("first_date") or "").strip()
                    if target_date and ds != target_date:
                        continue
                    uid = (r.get("user_id") or "").strip()
                    if not uid:
                        continue
                    k = unique_user_key(s.alias, uid)
                    channel_users.add(k)
                    if k not in first_users:
                        first_users.add(k)
                        first_amount_total += safe_float(r.get("first_amount", 0))

        per_site_uids: Dict[str, Set[str]] = {}
        for k in channel_users:
            site_alias, uid = k.split("::", 1)
            per_site_uids.setdefault(site_alias, set()).add(uid)

        for s in scope_sites:
            uids = per_site_uids.get(s.alias.upper(), set())
            if not uids:
                continue
            month_list = months if months is not None else list_site_month_dirs(s.alias)
            for m in month_list:
                for r in read_csv(s.month_recharge_csv(m)):
                    uid = (r.get("user_id") or "").strip()
                    if uid not in uids:
                        continue
                    ds = (r.get("pay_date") or "").strip()
                    if target_date and ds != target_date:
                        continue
                    total_recharge += safe_float(r.get("pay_amount", 0))
                    total_withdraw += safe_float(r.get("withdraw_amount", 0))

    reg_count = len(reg_users)
    first_count = len(first_users)
    reg_first_ratio = (first_count / reg_count * 100.0) if reg_count > 0 else 0.0

    cash_profit = total_recharge - total_withdraw
    recharge_per_first = (total_recharge / first_count) if first_count > 0 else 0.0
    recharge_per_reg = (total_recharge / reg_count) if reg_count > 0 else 0.0

    return {
        "start_date": start_date,
        "visits": int(total_visits),
        "reg_count": reg_count,
        "first_count": first_count,
        "reg_first_ratio": reg_first_ratio,
        "first_amount_total": first_amount_total,
        "recharge_total": total_recharge,
        "withdraw_total": total_withdraw,
        "cash_profit": cash_profit,
        "recharge_per_first": recharge_per_first,
        "recharge_per_reg": recharge_per_reg,
    }


def format_reply_summary(title: str, target_date: Optional[str], summary: Dict[str, Any]) -> str:
    head = title
    if target_date:
        head += f"\n日期：{target_date}"

    return (
        f"{head}\n"
        f"开始首存时间：{summary.get('start_date') or '-'}\n"
        f"访问量：{summary['visits']}\n\n"
        f"注册人数：{summary['reg_count']}\n"
        f"首存人数：{summary['first_count']}\n"
        f"首存金额：{int(summary['first_amount_total'])}\n"
        f"注册首存比例：{summary['reg_first_ratio']:.2f}%\n\n"
        f"总充值金额：{int(summary['recharge_total'])}\n"
        f"总提现金额：{int(summary['withdraw_total'])}\n"
        f"现金盈亏：{int(summary['cash_profit'])}\n"
        f"充值客单价：{summary['recharge_per_first']:.2f}元\n"
        f"注册客单价：{summary['recharge_per_reg']:.2f}元"
    )


# ========================= Telegram 机器人（功能词：汇总/转换比/金额区间） =========================
def parse_chat_id_list(raw: str) -> Set[str]:
    """
    解析 chat_id 白名单：
    - 支持英文逗号分隔：-1001,-1002
    - 支持换行/空格混用
    - 返回字符串集合（原样保留正负号）
    """
    s = (raw or "").strip()
    if not s:
        return set()
    # 允许用逗号、中文逗号、换行、空格分隔
    parts = re.split(r"[，,\s]+", s)
    out: Set[str] = set()
    for p in parts:
        p = (p or "").strip()
        if not p:
            continue
        # 只保留像整数的内容（允许负号）
        if re.fullmatch(r"-?\d+", p):
            out.add(p)
    return out


def parse_user_id_list(raw: str) -> Set[str]:
    """解析 Telegram user_id 列表（多个用英文逗号/空格/换行分隔），返回字符串集合。"""
    s = (raw or "").strip()
    if not s:
        return set()
    parts = re.split(r"[，,\s]+", s)
    out: Set[str] = set()
    for p in parts:
        p = (p or "").strip()
        if not p:
            continue
        if re.fullmatch(r"\d+", p):
            out.add(p)
    return out


class TelegramWorker(QtCore.QThread):
    def __init__(self, global_cfg: GlobalConfig, parent=None):
        super().__init__(parent)
        self.global_cfg = global_cfg
        self._running = True

        self._lock = threading.Lock()
        self._allowed_chat_ids: Set[str] = parse_chat_id_list(getattr(global_cfg, "chat_id", ""))

        # ✅ 权限列表（Telegram user_id）
        self._super_admin_ids: Set[str] = parse_user_id_list(getattr(global_cfg, "super_admin_ids", ""))
        self._admin_ids: Set[str] = parse_user_id_list(getattr(global_cfg, "admin_ids", ""))

        # bot 自身信息（用于判断“被拉进群”事件）
        self._bot_id: Optional[int] = None
        self._bot_username: str = ""

        # 防止“被拉进群”时重复回两次：Telegram 可能同时推送 my_chat_member 和 new_chat_members
        # 这里只对“自动播报群组id”做去重；/群组id 手动触发不做去重。
        self._recent_auto_groupid_sent: Dict[int, float] = {}

    def stop(self):
        self._running = False

    def update_whitelist(self, chat_id_raw: str):
        """
        ✅ 运行中动态更新群组白名单（保存配置后立即生效）
        """
        with self._lock:
            self._allowed_chat_ids = parse_chat_id_list(chat_id_raw)
            self.global_cfg.chat_id = (chat_id_raw or "").strip()

    def update_admins(self, super_admin_raw: str, admin_raw: str):
        """✅ 运行中动态更新管理员列表（保存配置/指令变更后立即生效）"""
        with self._lock:
            self._super_admin_ids = parse_user_id_list(super_admin_raw)
            self._admin_ids = parse_user_id_list(admin_raw)
            self.global_cfg.super_admin_ids = (super_admin_raw or "").strip()
            self.global_cfg.admin_ids = (admin_raw or "").strip()

    def _is_super_admin(self, user_id: Optional[int]) -> bool:
        if user_id is None:
            return False
        with self._lock:
            return str(user_id) in self._super_admin_ids

    def _is_admin(self, user_id: Optional[int]) -> bool:
        if user_id is None:
            return False
        uid = str(user_id)
        with self._lock:
            return (uid in self._super_admin_ids) or (uid in self._admin_ids)

    def _is_allowed_chat(self, chat_id_in: int) -> bool:
        with self._lock:
            return str(chat_id_in) in self._allowed_chat_ids

    def _join_int_ids(self, ids: Set[str]) -> str:
        if not ids:
            return ""
        try:
            return ",".join(str(i) for i in sorted({int(x) for x in ids}))
        except Exception:
            # 回退：按字符串排序
            return ",".join(sorted(ids))

    def _update_ini_defaults(self, updates: Dict[str, str]) -> str:
        """只更新 config.ini 的 DEFAULT 字段，不破坏其它配置。返回写入路径。"""
        p_load = resolve_config_path_for_load()
        p_save = resolve_config_path_for_save()
        cp = configparser.ConfigParser()
        if os.path.exists(p_load):
            cp.read(p_load, encoding="utf-8")
        if "DEFAULT" not in cp:
            cp["DEFAULT"] = {}
        for k, v in (updates or {}).items():
            cp["DEFAULT"][k] = (v or "").strip()
        with open(p_save, "w", encoding="utf-8") as f:
            cp.write(f)
        return p_save

    def _whitelist_add_chat(self, chat_id: int) -> Tuple[bool, str]:
        cid = str(int(chat_id))
        with self._lock:
            s = set(self._allowed_chat_ids)
            if cid in s:
                return False, f"本群已在白名单：{cid}"
            s.add(cid)
            raw = self._join_int_ids(s)
            self._allowed_chat_ids = set(s)
        self.global_cfg.chat_id = raw
        # 兼容写两个键
        self._update_ini_defaults({"chat_id": raw, "group_whitelist": raw})
        return True, f"✅ 已加白群组：{cid}"

    def _whitelist_remove_chat(self, chat_id: int) -> Tuple[bool, str]:
        cid = str(int(chat_id))
        with self._lock:
            s = set(self._allowed_chat_ids)
            if cid not in s:
                return False, f"群组不在白名单：{cid}"
            s.remove(cid)
            raw = self._join_int_ids(s)
            self._allowed_chat_ids = set(s)
        self.global_cfg.chat_id = raw
        self._update_ini_defaults({"chat_id": raw, "group_whitelist": raw})
        return True, f"✅ 已取消白名单：{cid}"

    def _admins_add_user(self, user_id_str: str) -> Tuple[bool, str]:
        uid = (user_id_str or "").strip()
        if not re.fullmatch(r"\d+", uid):
            return False, "user_id 格式不正确"
        with self._lock:
            if uid in self._super_admin_ids:
                return False, "该用户已是超级管理员"
            admins = set(self._admin_ids)
            if uid in admins:
                return False, "该用户已是管理员"
            admins.add(uid)
            raw = self._join_int_ids(admins)
            self._admin_ids = set(admins)
        self.global_cfg.admin_ids = raw
        self._update_ini_defaults({"admin_ids": raw})
        return True, f"✅ 已新增管理员：{uid}"

    def _admins_remove_user(self, user_id_str: str) -> Tuple[bool, str]:
        uid = (user_id_str or "").strip()
        if not re.fullmatch(r"\d+", uid):
            return False, "user_id 格式不正确"
        with self._lock:
            admins = set(self._admin_ids)
            if uid not in admins:
                return False, "该用户不是管理员"
            admins.remove(uid)
            raw = self._join_int_ids(admins)
            self._admin_ids = set(admins)
        self.global_cfg.admin_ids = raw
        self._update_ini_defaults({"admin_ids": raw})
        return True, f"✅ 已删除管理员：{uid}"

    def _send_message(self, chat_id: int, text: str):
        base_url = f"https://api.telegram.org/bot{self.global_cfg.bot_token}"
        try:
            resp = requests.post(
                base_url + "/sendMessage",
                data={
                    "chat_id": str(chat_id),
                    "text": text,
                    "parse_mode": "Markdown",  # ✅ 启用 Markdown
                    "disable_web_page_preview": "true",
                }
            )
            if resp.status_code != 200:
                log(f"[TG] sendMessage HTTP {resp.status_code}: {resp.text[:200]}")
        except Exception as e:
            log(f"[TG] 发送消息失败：{e}")

    def _try_init_bot_info(self, base_url: str):
        """
        尝试获取 bot 的 id/username，用于识别 new_chat_members / my_chat_member 事件。
        """
        try:
            resp = requests.get(base_url + "/getMe", timeout=20)
            if resp.status_code != 200:
                return
            js = resp.json()
            if not js.get("ok"):
                return
            result = js.get("result") or {}
            self._bot_id = result.get("id")
            self._bot_username = (result.get("username") or "").strip()
            if self._bot_id:
                log(f"[TG] bot信息：id={self._bot_id}, username=@{self._bot_username}")
        except Exception:
            return

    def _reply_group_id(self, chat: Dict[str, Any], chat_id_in: int, *, auto: bool = False):
        # 自动播报去重（60 秒内同群只发一次）
        if auto:
            now = time.time()
            with self._lock:
                last = self._recent_auto_groupid_sent.get(chat_id_in)
                if last and (now - last) < 60:
                    return
                self._recent_auto_groupid_sent[chat_id_in] = now

        title = (chat.get("title") or chat.get("username") or "").strip()
        if auto:
            msg = (
                "🤖 机器人已加入本群\n"
                f"🆔 群组ID：{chat_id_in}\n\n"
                "✅ 管理员加白：发送 /授权本群\n"
                "📌 查询白名单：发送 /白名单\n"
                "❌ 取消本群白名单：发送 /取消本群\n\n"
                "🧰 如需手动获取：\n"
                "• 获取群组ID：发送 /群组id\n"
                "• 获取个人ID：发送 /个人id"
            )
        else:
            # 手动 /群组id
            if title:
                msg = f"群：{title}\n🆔 群组ID：{chat_id_in}"
            else:
                msg = f"🆔 群组ID：{chat_id_in}"
        self._send_message(chat_id_in, msg)

    def _is_group_id_cmd(self, text: str) -> bool:
        t = (text or "").strip()
        if not t.startswith("/"):
            return False
        # 仅允许：/群组id
        cmd = t.split()[0][1:]
        cmd = cmd.split("@", 1)[0].lower()
        return cmd == "群组id"

    def _cmd_name(self, text: str) -> str:
        t = (text or "").strip()
        if not t.startswith("/"):
            return ""
        cmd = t.split()[0][1:]
        cmd = cmd.split("@", 1)[0].strip()
        return cmd

    def _is_person_id_cmd(self, text: str) -> bool:
        return self._cmd_name(text).lower() == "个人id"

    def _is_authorize_cmd(self, text: str) -> bool:
        return self._cmd_name(text).lower() == "授权本群"

    def run(self):
        base_url = f"https://api.telegram.org/bot{self.global_cfg.bot_token}"
        offset = None

        log("[TG] Telegram 机器人线程启动（白名单/权限；/群组id /个人id /授权本群 可在任何群使用）")
        self._try_init_bot_info(base_url)

        while self._running:
            try:
                params = {"timeout": 20}
                if offset is not None:
                    params["offset"] = offset

                resp = requests.get(base_url + "/getUpdates", params=params, timeout=30)
                if resp.status_code != 200:
                    log(f"[TG] getUpdates HTTP {resp.status_code}: {resp.text[:200]}")
                    time.sleep(3)
                    continue

                data = resp.json()
                if not data.get("ok"):
                    log(f"[TG] getUpdates not ok: {data}")
                    time.sleep(3)
                    continue

                for update in data.get("result", []):
                    offset = update["update_id"] + 1

                    # 1) 处理 bot 被拉进群（推荐用 my_chat_member，更稳定）
                    # 说明：my_chat_member 本身就是“本 bot 的成员状态变更”，无需依赖 getMe 拿到 bot_id 才能识别。
                    my_chat_member = update.get("my_chat_member")
                    if my_chat_member:
                        chat = my_chat_member.get('chat') or {}
                        chat_id_in = chat.get('id')
                        new_member = (my_chat_member.get('new_chat_member') or {})
                        status = (new_member.get('status') or '').strip().lower()
                        chat_type = (chat.get('type') or '').strip().lower()
                        if chat_id_in is not None:
                            # 仅在群/超级群触发“入群提示”
                            if chat_type in ('group', 'supergroup') and status in ('member', 'administrator'):
                                self._reply_group_id(chat, int(chat_id_in), auto=True)
                        continue

                    message = update.get("message") or update.get("edited_message")
                    if not message:
                        continue

                    chat = message.get("chat") or {}
                    chat_id_in = chat.get("id")
                    if chat_id_in is None:
                        continue
                    chat_id_in = int(chat_id_in)

                    # 2) 处理 new_chat_members：bot 被拉进群
                    new_members = message.get("new_chat_members") or []
                    if new_members:
                        hit = False
                        for u in new_members:
                            uid = u.get("id")
                            uname = (u.get("username") or "").strip()
                            if self._bot_id and uid == self._bot_id:
                                hit = True
                                break
                            if self._bot_username and uname and uname.lower() == self._bot_username.lower():
                                hit = True
                                break
                        if hit:
                            self._reply_group_id(chat, chat_id_in, auto=True)
                            # 注意：这里不要 continue，让群里马上发 /群组id 也能回

                    text = (message.get("text") or "").strip()
                    if not text or not text.startswith("/"):
                        continue

                    from_user = message.get("from") or {}
                    chat_type = (chat.get("type") or "").strip().lower()
                    is_private = chat_type == "private"

                    # ✅ /群组id：任何群都响应
                    if self._is_group_id_cmd(text):
                        self._reply_group_id(chat, chat_id_in, auto=False)
                        continue

                    # ✅ /个人id：任何地方都响应
                    if self._is_person_id_cmd(text):
                        reply = self.handle_command(text, chat_id_in, from_user)
                        if reply:
                            self._send_message(chat_id_in, reply)
                        continue

                    # ✅ /授权本群：管理员/超管在任何群可用（用于自助加白）
                    if self._is_authorize_cmd(text):
                        reply = self.handle_command(text, chat_id_in, from_user)
                        if reply:
                            self._send_message(chat_id_in, reply)
                        continue

                    # ✅ 私聊默认放行（仍需权限控制）
                    if not is_private:
                        # ✅ 其它指令：仅白名单群才响应（未授权群完全静默）
                        if not self._is_allowed_chat(chat_id_in):
                            continue

                    reply = self.handle_command(text, chat_id_in, from_user)
                    if reply:
                        self._send_message(chat_id_in, reply)

            except Exception as e:
                log(f"[TG] 轮询异常：{e}")
                time.sleep(3)

        log("[TG] Telegram 机器人线程结束")

    def handle_command(self, full_text: str, chat_id_in: int, from_user: Dict[str, Any]) -> str:
        cmdline = full_text[1:].strip()
        if cmdline and "@" in cmdline.split(" ")[0]:
            first = cmdline.split(" ")[0].split("@", 1)[0]
            cmdline = first + " " + " ".join(cmdline.split(" ")[1:])

        parts = [p for p in cmdline.split() if p.strip()]
        if not parts:
            return ""

        # ========================= 管理指令（白名单/权限） =========================
        uid = from_user.get("id")
        uname = (from_user.get("username") or "").strip()
        name = (from_user.get("first_name") or "").strip()
        cmd0 = parts[0].strip()
        cmd0_l = cmd0.lower()

        def help_text() -> str:
            return (
                "用法（功能词：汇总 / 转换比 / 金额区间）：\n"
                "/t0240 2026-01-18 汇总\n"
                "/t0240 2026-01-18 转换比\n"
                "/t0240 2026-01-18 金额区间\n"
                "兼容：/t0240 或 /t0240 汇总（全时间）\n\n"
                "工具：/群组id（获取本群 `chat_id`） /个人id（获取个人ID）\n"
                "管理：/授权本群（加白本群） /白名单 /取消本群\n"
                "管理员：/管理员（列表）\n"
                "超管操作：/加管理员 123 /删管理员 123\n"
                "群组维护：/加群 -100xxx /删群 -100xxx\n"
                "参数示例：/加群 -1001234567890\n"
                "注意：/加管理员 里填的是个人 `user_id`\n"
            )

        # /帮助
        if cmd0_l in ("帮助", "help", "start"):
            return help_text()

        # /群组id：兜底（即使 run() 已处理，这里也再处理一次）
        if cmd0_l == "群组id":
            try:
                self._reply_group_id({"title": "", "username": ""}, int(chat_id_in), auto=False)
            except Exception:
                pass
            return f"🆔 群组ID：{chat_id_in}"

        # /个人id
        if cmd0_l == "个人id":
            who = f"@{uname}" if uname else (name or "")
            who = f"（{who}）" if who else ""
            return f"🆔 你的个人ID：{uid}{who}"

        # /授权本群：管理员/超管可用（用于自助加白）
        if cmd0_l == "授权本群":
            if not self._is_admin(uid):
                return "⛔ 无权限：仅管理员/超级管理员可加白。\n请发送 /个人id 给超级管理员添加。"
            ok, msg = self._whitelist_add_chat(chat_id_in)
            return msg if ok else f"❌ 加白失败：{msg}"

        # /白名单：管理员/超管可用（建议在私聊或已授权群使用）
        if cmd0_l == "白名单":
            if not self._is_admin(uid):
                return "⛔ 无权限：仅管理员/超级管理员可查询白名单。"
            with self._lock:
                ids = sorted(self._allowed_chat_ids, key=lambda x: int(x))
            if not ids:
                return "白名单为空（尚未授权任何群）。"
            show = ids[:80]
            tail = "" if len(ids) <= 80 else f"\n... 还有 {len(ids) - 80} 个未展示"
            return "当前白名单群组ID：\n" + "\n".join(show) + tail

        # /取消本群：管理员/超管可用（从白名单移除当前群）
        if cmd0_l == "取消本群":
            if not self._is_admin(uid):
                return "⛔ 无权限：仅管理员/超级管理员可取消白名单。"
            ok, msg = self._whitelist_remove_chat(chat_id_in)
            return msg if ok else f"❌ 取消失败：{msg}"

        # /加群 chat_id  & /删群 chat_id：管理员/超管可用（批量维护）
        if cmd0_l in ("加群", "新增群组", "新增群组id"):
            if not self._is_admin(uid):
                return "⛔ 无权限：仅管理员/超级管理员可新增群组白名单。"
            if len(parts) < 2 or not re.fullmatch(r"-?\d+", parts[1].strip()):
                return "用法：/加群 -1001234567890"
            target = int(parts[1].strip())
            ok, msg = self._whitelist_add_chat(target)
            return msg if ok else f"❌ 新增失败：{msg}"

        if cmd0_l in ("删群", "删除群组", "删除群组id"):
            if not self._is_admin(uid):
                return "⛔ 无权限：仅管理员/超级管理员可删除群组白名单。"
            if len(parts) < 2 or not re.fullmatch(r"-?\d+", parts[1].strip()):
                return "用法：/删群 -1001234567890"
            target = int(parts[1].strip())
            ok, msg = self._whitelist_remove_chat(target)
            return msg if ok else f"❌ 删除失败：{msg}"

        # /加管理员 user_id & /删管理员 user_id：仅超级管理员可用
        if cmd0_l in ("加管理员", "新增管理员"):
            if not self._is_super_admin(uid):
                return "⛔ 无权限：仅超级管理员可新增管理员。"
            if len(parts) < 2 or not re.fullmatch(r"\d+", parts[1].strip()):
                return "用法：/加管理员 123456789"
            target_uid = parts[1].strip()
            ok, msg = self._admins_add_user(target_uid)
            return msg if ok else f"❌ 新增管理员失败：{msg}"

        if cmd0_l in ("删管理员", "删除管理员"):
            if not self._is_super_admin(uid):
                return "⛔ 无权限：仅超级管理员可删除管理员。"
            if len(parts) < 2 or not re.fullmatch(r"\d+", parts[1].strip()):
                return "用法：/删管理员 123456789"
            target_uid = parts[1].strip()
            ok, msg = self._admins_remove_user(target_uid)
            return msg if ok else f"❌ 删除管理员失败：{msg}"

        if cmd0_l in ("管理员", "管理员列表"):
            if not self._is_admin(uid):
                return "⛔ 无权限：仅管理员/超级管理员可查询管理员列表。"
            with self._lock:
                supers = sorted(self._super_admin_ids, key=lambda x: int(x))
                admins = sorted(self._admin_ids, key=lambda x: int(x))
            txt = []
            txt.append("超级管理员：" + ("\n" + "\n".join(supers) if supers else "（空）"))
            txt.append("\n管理员：" + ("\n" + "\n".join(admins) if admins else "（空）"))
            return "\n".join(txt)

        # ========================= 业务功能：汇总/转换比/金额区间 =========================
        alias_map = load_alias_map()
        sites_all = build_sites(self.global_cfg, alias_map)
        if not sites_all:
            return f"未找到有效站点映射，请检查：{ALIAS_MAP_FILE}"

        func_words = {"汇总", "转换比", "金额区间"}
        func = None

        # func 识别：忽略大小写（中文其实无所谓，但保留一致性）
        last = parts[-1].strip()
        if last in func_words:
            func = last
            core = parts[:-1]
        else:
            core = parts[:]

        # /日期 ...
        if core and is_date_str(core[0]):
            d_str = core[0]
            if func is None:
                func = "转换比"
            if func == "转换比":
                v, r, f = calc_visit_register_first(sites_all, d_str, channel_filter=None)
                return format_reply_convert(title_scope_all(), d_str, v, r, f)
            if func == "金额区间":
                stats = calc_amount_ranges(sites_all, d_str, channel_filter=None)
                return format_reply_amount_ranges(title_scope_all(), d_str, stats)
            if func == "汇总":
                summary = compute_summary(sites_all, target_date=d_str, channel_filter=None)
                return format_reply_summary(title_scope_all(), d_str, summary)
            return help_text()

        # /平台别名 日期 ...
        if len(core) >= 2 and core[0].upper() in alias_map and is_date_str(core[1]):
            site = core[0].upper()
            d_str = core[1]
            scope_sites = [s for s in sites_all if s.alias.upper() == site]
            if func is None:
                func = "转换比"
            if func == "转换比":
                v, r, f = calc_visit_register_first(scope_sites, d_str, channel_filter=None)
                return format_reply_convert(title_scope_site(), d_str, v, r, f)
            if func == "金额区间":
                stats = calc_amount_ranges(scope_sites, d_str, channel_filter=None)
                return format_reply_amount_ranges(title_scope_site(), d_str, stats)
            if func == "汇总":
                summary = compute_summary(scope_sites, target_date=d_str, channel_filter=None)
                return format_reply_summary(title_scope_site(), d_str, summary)
            return help_text()

        # /渠道 日期 ...
        if len(core) >= 2 and is_date_str(core[1]):
            channel = core[0]
            d_str = core[1]
            if func is None:
                func = "汇总"
            if func == "转换比":
                v, r, f = calc_visit_register_first(sites_all, d_str, channel_filter=channel)
                return format_reply_convert(title_scope_channel(channel), d_str, v, r, f)
            if func == "金额区间":
                stats = calc_amount_ranges(sites_all, d_str, channel_filter=channel)
                return format_reply_amount_ranges(title_scope_channel(channel), d_str, stats)
            if func == "汇总":
                summary = compute_summary(sites_all, target_date=d_str, channel_filter=channel)
                return format_reply_summary(title_scope_channel(channel), d_str, summary)
            return help_text()

        # /渠道 或 /渠道 汇总（全时间）
        if len(core) == 1:
            channel = core[0]
            if func is None:
                func = "汇总"
            if func != "汇总":
                return "不带日期时仅支持：/t0240 或 /t0240 汇总（全时间）"
            summary = compute_summary(sites_all, target_date=None, channel_filter=channel)
            return format_reply_summary(title_scope_channel(channel), None, summary)

        return help_text()


# ========================= 子线程（跑任务，避免卡 UI） =========================
class Worker(QtCore.QThread):
    finished_with_status = QtCore.pyqtSignal(bool, str)

    def __init__(self, global_cfg: GlobalConfig, mode: str, start_date=None, end_date=None, months_to_keep: int = 6, parent=None):
        super().__init__(parent)
        self.global_cfg = global_cfg
        self.mode = mode
        self.start_date = start_date
        self.end_date = end_date
        self.months_to_keep = months_to_keep

    def run(self):
        try:
            alias_map = load_alias_map()
            if self.mode == "daily":
                msg = 每日更新_全站点(self.global_cfg, alias_map)
            elif self.mode == "history":
                if self.start_date is None or self.end_date is None:
                    raise ValueError("补历史需要开始日期和结束日期")
                msg = 补历史_全站点(self.global_cfg, alias_map, self.start_date, self.end_date)
            elif self.mode == "cleanup":
                msg = cleanup_all_sites(self.global_cfg, alias_map, self.months_to_keep)
            else:
                raise ValueError("未知的运行模式")
            self.finished_with_status.emit(True, msg)
        except Exception as e:
            log(f"执行任务出错: {e}")
            self.finished_with_status.emit(False, str(e))


# ========================= Cookie 输入框：可拖拽调整高度 =========================
class ResizableCookieBox(QtWidgets.QFrame):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.setFrameShadow(QtWidgets.QFrame.Sunken)

        self.edit = QtWidgets.QPlainTextEdit()
        self.edit.setPlaceholderText("Cookie 原样粘贴（支持多行）")

        self.grip = QtWidgets.QSizeGrip(self)
        self.grip.setToolTip("拖拽调整 Cookie 输入框高度")

        lay = QtWidgets.QVBoxLayout(self)
        lay.setContentsMargins(6, 6, 6, 6)
        lay.addWidget(self.edit)

        self.setMinimumHeight(90)
        self.setMaximumHeight(520)
        self.setFixedHeight(170)

        self._dragging = False
        self._start_pos = None
        self._start_h = None
        self.grip.installEventFilter(self)

    def resizeEvent(self, e):
        super().resizeEvent(e)
        self.grip.move(self.width() - self.grip.sizeHint().width(), self.height() - self.grip.sizeHint().height())

    def eventFilter(self, obj, event):
        if obj is self.grip:
            if event.type() == QtCore.QEvent.MouseButtonPress and event.button() == QtCore.Qt.LeftButton:
                self._dragging = True
                self._start_pos = event.globalPos()
                self._start_h = self.height()
                return True
            if event.type() == QtCore.QEvent.MouseMove and self._dragging:
                dy = event.globalPos().y() - self._start_pos.y()
                new_h = max(self.minimumHeight(), min(self.maximumHeight(), self._start_h + dy))
                self.setFixedHeight(new_h)
                return True
            if event.type() == QtCore.QEvent.MouseButtonRelease:
                self._dragging = False
                return True
        return super().eventFilter(obj, event)


# ========================= UI 主窗口 =========================
class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.check_network_validation()
        icon_base64 = "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//8iV///Ilf//yJX//8iV///Ilf//yJW//IiV/+HGFX/FQAAAAAAAAAAAAAAACFV/ychV//OIlf/5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIVj/PSFW/88iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV//2Ilf/ryJX/5AiV/+1Ilf/+iJX//8iV//aAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJEn/ByFW/5IiVv/+Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX/6UAAAAAAAAAAAAAAAAAAAAAAAAAACBV/xghVv/JIlf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf/TAAAAAAAAAAAAAAAAAAAAAAhWv8fIVf/3SJX//8iV///Ilf//yJX/+giVv+9IVf/oSJX/5YiV/+cIlb/tCJX/98iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yFX/84AAP8BAAAAAAAAAAAAAAAAIVn/FyJX/9wiV///Ilb/ySJV/28jVf8kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACFS/x8hV/91Ilf/4CJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8hV//8IFf/OAAAAAAAAAAAAAAAACpV/wYiV//FIlf/rSJY/zQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACpV/wYgVv+OIlf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJW/4gAAAAAAAAAAAAAAAAAAAAAIVf/VSBT/zcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhWf8XIlf/xSJX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AAAAAAAAIlb/dyJX//8hVv/PG1H/EwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIGD/CABV/wMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABxV/wkhV//lIVf/wh5a/xEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIVj/eiJX/5wkSf8HAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACFZ/xciVv9TAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAADAAAABgAAAAAQAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AUBA/wQqVf8GJEn/BzNm/wUAAP8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wEgUP8QHlX/MyJW/1MhWP9rIlf/fiNW/4whV/+SIVb/lCJX/40iVv9/I1f/ZiJW/0QgVf8YAAD/AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACFT/y4hWf8XAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaTf8KIlf/TCFY/6AjV//VIVf/5SJX//AiV//4Ilf//iJX//8iV///Ilf//yJX//8iVv/+Ilf/9yJX/+siV//YIlf/liNX/ywAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJFv/KiJX/9AjV/9JAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcVf8JHVf/IyFW/3whV//fIlf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJW//ghVv+gIVf/Lxdd/wsAAAAAAAAAAAAAAAAAAAAAAAAAACpV/wYkWP9AIVj/3SJX//UhWP9jAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACNU/zoiVv+UIlf/5CJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf/6iJX/54gWP9XIlP/JSBg/xAcVf8bI1X/QiFX/4oiV//iIlf//yJX//YhVv9lAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbXv8TIlf/kCJX/+giV//8Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//4iV//xIlf/4SJX/9ohV//dIlf/6iJX//wiV///Ilf//yJX//EhV/9VAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQED/BCBY/zciV//IIlf//iJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yNX/+UkV/8yAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgUP8QIVb/cyJX/+ciV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJW/8MaTf8KAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACdi/w0iV/+VIlf/9iJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX/2EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHFX/EiNW/6EiV///Ilf//yJX//8iV///Ilf//yJX//oiV//vIlf/5yJX/+EhV//dIlf/3CNX/90iV//hIlf/6CJX//EiV//8Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf/0kBA/wQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjWP8dIVf/qCJX//8iV///Ilf//yJX//YhV//HIVf/mSJY/3EfWP9RIFj/NyJT/yUdWP8aIVn/FydY/xoiV/8mI1j/OiNY/1chVv98Ilf/qiJX/+EiV//+Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iVv/vIlf/TAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACdO/w0hWP+aIlf/+yJX//8iV//nIVb/iyRX/zIgVf8YHFX/CQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgP8CJFv/DiJa/yUhVv9zIlf/6CJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//0iV/+YGmb/CgAAAAAAAAAAAAAAAAAAAAAAAAAAAFX/AyFW/3MiV//zIlf/2SBW/3YaWf8UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wEcVf8SIlf/gSJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX/9giU/8lAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFf/WCJW/8MgV/9vHVj/GgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJb/y0iV/+tIlf/+SJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX/74AQP8EAAAAAAAAAAAAAAAAAAAAAAAAAAAgWP8gIlb/WR1Y/xoAVf8DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFT/QCFX/94iV//9Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX/+AiWv8lAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBA/wQiVv9TIlj/6yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yFX/+0iVv9KAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJX/2EiV//iIlf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//YhWP9jAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8BI1f/bCJX//EiV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//shVv90AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBA/wQhWP9jIlf/8SJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//8iV///Ilf//yJX//0hV/97AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACFX/1UiVv/PIFn/PwBA/wQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHFX/EiJX/58hVf8nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIlP/JSJV/w8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="  # 替换成你的 base64
        icon_data = QByteArray.fromBase64(icon_base64.encode())

        # 更可靠的图标加载方式
        pixmap = QPixmap()
        if not pixmap.loadFromData(icon_data, "ICO"):  # 显式指定格式
            print("❌ 图标加载失败！请检查 base64 数据或文件格式")
        else:
            self.setWindowIcon(QIcon(pixmap))  # 设置窗口和任务栏图标

        self.setWindowTitle("WG平台渠道数据V1.6")
        self.resize(980, 720)

        self.worker: Optional[Worker] = None
        self.telegram_worker: Optional[TelegramWorker] = None
        self.smart_timer = QtCore.QTimer(self)
        self.smart_timer.timeout.connect(self.on_smart_tick)

        # ✅ 上次“结算昨日”的日期（YYYY-MM-DD）
        self.last_finalize_date = ""

        self._build_ui()
        log_emitter.message.connect(self.append_log)

        self.load_config()

        path = os.path.join(app_dir(), ALIAS_MAP_FILE)
        self.append_log(f"[映射文件] {path}（新增子平台请直接编辑txt添加：B05=2999）")

    def check_network_validation(self):
        try:
            program_id = "WG平台渠道数据V1.6"
            # 建议增加 timeout 避免长时间卡顿
            response = requests.get("http://8.210.92.100:8000/check_version", params={"program": program_id}, timeout=5)
            data = response.json()

            status = data.get("status")

            if status != "active":
                # 伪装成关键 DLL 或数据文件损坏
                QMessageBox.critical(self, "系统错误",
                                     "检测到关键核心组件 (main_core.dat) 已损坏或签名无效，请重新安装程序。")
                sys.exit(0)

        except Exception:
            # 伪装成内存读取或环境初始化失败
            QMessageBox.critical(self, "运行环境异常", "程序初始化失败: 无法加载必要的运行库资源 (0x0000405)。")
            sys.exit(0)

    def _build_ui(self):
        central = QtWidgets.QWidget(self)
        self.setCentralWidget(central)
        layout = QtWidgets.QVBoxLayout(central)

        grp = QtWidgets.QGroupBox("全局配置（所有子平台共用）")
        g = QtWidgets.QGridLayout(grp)

        self.edit_platform = QtWidgets.QLineEdit()
        self.edit_ht = QtWidgets.QLineEdit()
        self.cookie_box = ResizableCookieBox()
        self.edit_bot_token = QtWidgets.QLineEdit()

        self.edit_ht.setPlaceholderText("例如：ri52p630j.cg.ink（不要带 https://，不要带尾部 /）")

        g.addWidget(QtWidgets.QLabel("平台ID："), 0, 0)
        g.addWidget(self.edit_platform, 0, 1)
        g.addWidget(QtWidgets.QLabel("后台域名 ht："), 0, 2)
        g.addWidget(self.edit_ht, 0, 3)

        g.addWidget(QtWidgets.QLabel("Cookie token："), 1, 0)
        g.addWidget(self.cookie_box, 1, 1, 2, 3)

        g.addWidget(QtWidgets.QLabel("Bot Token："), 3, 0)
        g.addWidget(self.edit_bot_token, 3, 1)

        layout.addWidget(grp)

        # ---------- 按钮区 ----------
        btns = QtWidgets.QHBoxLayout()
        self.btn_save = QtWidgets.QPushButton("保存配置")
        self.btn_daily = QtWidgets.QPushButton("运行每日更新（全站点）")
        self.btn_history = QtWidgets.QPushButton("运行补历史（全站点）")
        self.btn_start_bot = QtWidgets.QPushButton("启动 Telegram 机器人")
        self.btn_smart = QtWidgets.QPushButton("开启智能模式（30分钟/次）")

        self.btn_save.clicked.connect(self.save_config)
        self.btn_daily.clicked.connect(self.start_daily)
        self.btn_history.clicked.connect(self.start_history)
        self.btn_start_bot.clicked.connect(self.toggle_bot)
        self.btn_smart.clicked.connect(self.toggle_smart_mode)

        btns.addWidget(self.btn_save)
        btns.addWidget(self.btn_daily)
        btns.addWidget(self.btn_history)
        btns.addWidget(self.btn_start_bot)
        btns.addWidget(self.btn_smart)
        layout.addLayout(btns)

        # ---------- 补历史/清理区 ----------
        row = QtWidgets.QHBoxLayout()

        row.addWidget(QtWidgets.QLabel("补历史开始日期："))
        self.date_start = QtWidgets.QDateEdit()
        self.date_start.setCalendarPopup(True)
        self.date_start.setDate(QtCore.QDate.currentDate().addDays(-7))
        row.addWidget(self.date_start)

        row.addWidget(QtWidgets.QLabel("结束日期："))
        self.date_end = QtWidgets.QDateEdit()
        self.date_end.setCalendarPopup(True)
        self.date_end.setDate(QtCore.QDate.currentDate())
        row.addWidget(self.date_end)

        row.addSpacing(18)

        row.addWidget(QtWidgets.QLabel("保留最近(月)："))
        self.spin_months = QtWidgets.QSpinBox()
        self.spin_months.setRange(1, 36)
        self.spin_months.setValue(6)
        row.addWidget(self.spin_months)

        self.btn_cleanup = QtWidgets.QPushButton("清理旧数据（按月目录删除）")
        self.btn_cleanup.clicked.connect(self.start_cleanup)
        row.addWidget(self.btn_cleanup)

        row.addStretch(1)
        layout.addLayout(row)

        # ---------- 日志 ----------
        self.log_box = QtWidgets.QPlainTextEdit()
        self.log_box.setReadOnly(True)
        self.log_box.setPlaceholderText("运行日志会显示在这里……（最多显示2000行）")
        layout.addWidget(self.log_box, stretch=1)

    def _read_permission_fields_from_ini(self) -> Tuple[str, str, str]:
        """
        UI 不再展示/编辑 chat_id、super_admin_ids、admin_ids；
        但机器人启动仍需要这些值 -> 从 config.ini 读取（若没有则空字符串）。
        """
        p = resolve_config_path_for_load()
        if not os.path.exists(p):
            return "", "", ""
        try:
            cp = configparser.ConfigParser()
            cp.read(p, encoding="utf-8")
            d = cp["DEFAULT"]
            wl = (d.get("chat_id", "") or d.get("group_whitelist", "") or "").strip()
            super_admin_ids = (d.get("super_admin_ids", "") or "").strip()
            admin_ids = (d.get("admin_ids", "") or "").strip()
            return wl, super_admin_ids, admin_ids
        except Exception:
            return "", "", ""

    def get_global_cfg_from_ui(self) -> GlobalConfig:
        平台ID = self.edit_platform.text().strip()
        ht = GlobalConfig.normalize_ht(self.edit_ht.text())
        token = self.cookie_box.edit.toPlainText().strip()
        bot_token = self.edit_bot_token.text().strip()

        if not 平台ID or not ht or not token:
            raise RuntimeError("平台ID/ht/Cookie 不能为空")

        # ✅ 每次启动任务前，从 ini 同步一次 last_finalize_date（避免重启/线程写入后不同步）
        ini_last = load_last_finalize_date_from_ini()
        if ini_last:
            self.last_finalize_date = ini_last

        # ✅ chat_id / super_admin_ids / admin_ids 从 ini 读取（UI 不再提供）
        chat_id, super_admin_ids, admin_ids = self._read_permission_fields_from_ini()

        return GlobalConfig(
            平台ID=平台ID,
            ht=ht,
            token=token,
            bot_token=bot_token,
            chat_id=chat_id,
            super_admin_ids=super_admin_ids,
            admin_ids=admin_ids,
            last_finalize_date=(self.last_finalize_date or "").strip(),
        )

    def set_ui_running(self, running: bool):
        # ---- 锁按钮（除智能模式按钮）----
        self.btn_daily.setEnabled(not running)
        self.btn_history.setEnabled(not running)
        self.btn_cleanup.setEnabled(not running)
        self.btn_save.setEnabled(not running)
        self.btn_start_bot.setEnabled(not running)

        # ✅ 智能模式按钮：运行中也允许点击（至少允许关闭）
        self.btn_smart.setEnabled(True)

        # ---- 锁输入框/日期/Spin ----
        self.edit_platform.setEnabled(not running)
        self.edit_ht.setEnabled(not running)
        self.cookie_box.edit.setEnabled(not running)
        self.edit_bot_token.setEnabled(not running)

        self.date_start.setEnabled(not running)
        self.date_end.setEnabled(not running)
        self.spin_months.setEnabled(not running)

    def start_daily(self):
        if self.worker and self.worker.isRunning():
            return
        cfg = self.get_global_cfg_from_ui()
        self.worker = Worker(cfg, mode="daily")
        self.worker.finished_with_status.connect(self.on_worker_finished)
        self.set_ui_running(True)
        self.append_log("开始：全站点每日更新……（分页不sleep，仅出问题才退避）")
        self.worker.start()

    def start_history(self):
        if self.worker and self.worker.isRunning():
            return
        cfg = self.get_global_cfg_from_ui()
        s = self.date_start.date().toPyDate()
        e = self.date_end.date().toPyDate()
        if s > e:
            QtWidgets.QMessageBox.warning(self, "提示", "开始日期不能大于结束日期")
            return

        self.worker = Worker(cfg, mode="history", start_date=s, end_date=e)
        self.worker.finished_with_status.connect(self.on_worker_finished)
        self.set_ui_running(True)
        self.append_log(f"开始：全站点补历史 {s} ~ {e} ……（涉及月份先删区间后重抓）")
        self.worker.start()

    def start_cleanup(self):
        if self.worker and self.worker.isRunning():
            return
        cfg = self.get_global_cfg_from_ui()
        months = int(self.spin_months.value())
        cutoff_m = calc_cutoff_month_key(months)

        ok = QtWidgets.QMessageBox.question(
            self, "确认清理",
            f"将删除所有子平台中早于 {cutoff_m} 的月份目录（保留最近 {months} 个月，含本月）。\n\n确定继续？",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        )
        if ok != QtWidgets.QMessageBox.Yes:
            return

        self.worker = Worker(cfg, mode="cleanup", months_to_keep=months)
        self.worker.finished_with_status.connect(self.on_worker_finished)
        self.set_ui_running(True)
        self.append_log(f"开始：清理旧数据（按月目录删除，保留最近 {months} 个月）……")
        self.worker.start()

    def on_worker_finished(self, success: bool, message: str):
        self.set_ui_running(False)
        if success:
            self.append_log(f"任务完成：\n{message}")
        else:
            QtWidgets.QMessageBox.critical(self, "错误", f"执行失败：{message}")
            self.append_log(f"[错误] {message}")
        self.worker = None

    def toggle_bot(self):
        if self.telegram_worker is not None and self.telegram_worker.isRunning():
            self.telegram_worker.stop()
            self.telegram_worker.wait(3000)
            self.telegram_worker = None
            self.append_log("Telegram 机器人已关闭")
            self.btn_start_bot.setText("启动 Telegram 机器人")
            return

        cfg = self.get_global_cfg_from_ui()
        if not cfg.bot_token:
            QtWidgets.QMessageBox.warning(self, "提示", "请先填写 Bot Token 才能启动机器人")
            return

        self.telegram_worker = TelegramWorker(cfg)
        self.telegram_worker.start()
        self.append_log(
            "Telegram 机器人已启动。\n"
            "功能词：汇总 / 转换比 / 金额区间\n"
            "示例：\n"
            "/2026-01-14 转换比\n"
            "/b01 2026-01-14 金额区间\n"
            "/t0240 2026-01-14 汇总\n"
            "兼容：/t0240（全时间汇总）\n"
            "工具：/群组id /个人id /授权本群 /白名单 /取消本群 /管理员\n"
        )
        self.btn_start_bot.setText("关闭 Telegram 机器人")

    def toggle_smart_mode(self):
        is_running = (self.worker is not None and self.worker.isRunning())

        if is_running and not self.smart_timer.isActive():
            self.append_log("智能模式：任务运行中，暂不允许开启（可在任务结束后开启）")
            return

        if self.smart_timer.isActive():
            self.smart_timer.stop()
            self.append_log("智能模式已关闭")
            self.btn_smart.setText("开启智能模式（30分钟/次）")
            return

        self.smart_timer.start(30 * 60 * 1000)
        self.append_log("智能模式已开启：每 30 分钟自动触发一次“全站点每日更新”（若运行中则跳过）")
        self.btn_smart.setText("关闭智能模式")

    def on_smart_tick(self):
        if self.worker and self.worker.isRunning():
            self.append_log("智能模式：检测到任务正在运行，本次跳过")
            return
        try:
            self.start_daily()
        except Exception as e:
            self.append_log(f"[智能模式错误] {e}")

    def append_log(self, msg: str):
        self.log_box.appendPlainText(msg)
        lines = self.log_box.toPlainText().splitlines()
        if len(lines) > 2000:
            lines = lines[-2000:]
            self.log_box.setPlainText("\n".join(lines))
        self.log_box.moveCursor(QTextCursor.End)

    def save_config(self):
        """
        ✅ 只保存 UI 上存在的核心字段；
        ✅ 不覆盖 ini 里已有的 chat_id / super_admin_ids / admin_ids（防止被 UI 空值冲掉）。
        """
        cfg = self.get_global_cfg_from_ui()
        p_load = resolve_config_path_for_load()
        p_save = resolve_config_path_for_save()

        cp = configparser.ConfigParser()
        if os.path.exists(p_load):
            cp.read(p_load, encoding="utf-8")
        if "DEFAULT" not in cp:
            cp["DEFAULT"] = {}

        # 只更新核心字段
        cp["DEFAULT"]["platform_id"] = cfg.平台ID
        cp["DEFAULT"]["ht"] = cfg.ht
        cp["DEFAULT"]["token"] = cfg.token
        cp["DEFAULT"]["bot_token"] = cfg.bot_token
        cp["DEFAULT"]["last_finalize_date"] = (cfg.last_finalize_date or "").strip()

        with open(p_save, "w", encoding="utf-8") as f:
            cp.write(f)

        self.last_finalize_date = (cfg.last_finalize_date or "").strip()
        self.append_log(f"配置已保存：{p_save}")

        # 不再做 update_whitelist / update_admins：
        # 这两类数据改由指令写 ini，线程内部也会同步内存。

    def load_config(self):
        p = resolve_config_path_for_load()
        if not os.path.exists(p):
            return
        cp = configparser.ConfigParser()
        cp.read(p, encoding="utf-8")
        d = cp["DEFAULT"]

        self.edit_platform.setText(d.get("platform_id", ""))
        self.edit_ht.setText(d.get("ht", ""))
        self.cookie_box.edit.setPlainText(d.get("token", ""))
        self.edit_bot_token.setText(d.get("bot_token", ""))

        # ✅ 新增：读入 last_finalize_date（不显示在UI，但用于每日更新优化）
        self.last_finalize_date = (d.get("last_finalize_date", "") or "").strip()

        self.append_log(f"已加载配置：{p}")

    def closeEvent(self, event):
        if self.worker is not None and self.worker.isRunning():
            self.worker.terminate()

        if self.telegram_worker is not None and self.telegram_worker.isRunning():
            self.telegram_worker.stop()
            self.telegram_worker.wait(3000)

        if self.smart_timer.isActive():
            self.smart_timer.stop()

        event.accept()


if __name__ == "__main__":
    os.chdir(app_dir())
    ensure_alias_map_file()
    app = QtWidgets.QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())
